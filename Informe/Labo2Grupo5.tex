\documentclass[12pt, letterpaper]{article}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{float}
\usepackage[spanish,es-tabla]{babel}
\graphicspath{{img/}}


\begin{document}

\begin{center}
    ''Año del Fortalecimiento de la Soberania Nacional''
    \vspace{5mm}
    \begin{figure}[h]
        \centering
        \includegraphics[width=4cm,height=4cm]{UNMSM}
    \end{figure}

    \textbf{Universidad Nacional Mayor de San Marcos} \\
    (Universidad del Perú,DECANA DE AMERICA)\\
    \vspace{5mm}
    FACULTAD DE INGENIERIA DE SISTEMAS E INFORMATICA
    Escuela Profesional de Ingenieria de Software
    \begin{figure}[h]
        \centering   
        \includegraphics[width=2cm,height=2cm]{FISI}   
    \end{figure}

\textbf{\underline{Segundo Laboratorio: Laboratorio Python}}

    \begin{flushleft}
    \textbf{Curso:}Programacion Paralela y Concurrente\\
    \vspace{2mm}
    \textbf{Profesor:} Edson Ticona Zegarra\\
    \vspace{2mm}
    \textbf{Integrantes:} 
    \begin{itemize}
        \item Pichilingue Pimentel, Nathaly Nicole\hspace{1cm} 19200247
        \item Torre Arteaga, Alexander\hspace{3.2cm}19200246
        \item Ricse Perez, Anthony Elias\hspace{3cm}19200276
    \end{itemize}
    \end{flushleft}

    Ciudad Universitaria 2022
 
\end{center}

\vspace{10mm}
\begin{flushleft}
    \begin{enumerate}
        \item \textbf{Explicación del algoritmo implementado}
        \begin{itemize}
            \item \textbf{Cuestiones generales}
            Las distintas versiones del algoritmo realizado fueron implementadas en Python, haciendo uso del Python nativo, y liberías como Cython y OpenMP.
            Para realizar la evaluación de la entrada, se creó una función que genera una lista de n círculos con sus respectivos datos como posición xy, radio y color rgb. Luego, en base a esos datos, se traza el círculo, se detecta los píxeles afectados y se realiza la modificación en el archivo PPM, lo que permite dibujar los círculos deseados.
            Consideraciones a tomar en nuestro código:
        \begin{itemize}
            \item Nuestro algoritmo solo toma como valores de entrada válidos, números enteros , negativos o positivos.
        \end{itemize}
            \item \textbf{Función principal}
            La función principal implementada en el proyecto llama a la función de entrada, donde ingresaremos los datos necesarios para dibujar el(los) circulo(s). Una vez se retorne la lista de cícrculos como respuesta, se llama a la función de creación de canvas en archivo PPM y luego a la función de dibujo, que nos retornará una matriz de píxeles. Con dicha matriz, se procede a llamar a la función de escritura de archivo, que modificará el canvas PPM creado incialmente según la posición y el canal de colores rgb de los píxeles obtenidos, finalizando así nla ejecución del programa.
            \item \textbf{Función de entrada}
            La función de entrada llamada ''entrada'' inicia solicitando al usuario que ingrese el número de círculos a dibujar, una vez obtenido el número de cícrlos, se realiza una loop para solicitar los siguiente datos por cada círculo: coordenada (x,y) que representa el eje del círculo, radio del círculo, y valores para cada canal de color rgb del círculo, en el orden rojo, verde y azul. Luego, guarda dichos datos en una lista llamada círculos y retorna dicha lista.
            \item \textbf{Función de creación de canvas}
            La función de creación del canvas, llamada create\_image, genera una imagen del tamaño 1024 por 960 preestablecido multiplicando con el valor de los canales de color negro, representado en rgb como 000 (respectivamente para cada canal de color), y finalmente guarda el resultado en una lista, que es el retorno de la función.
            \item \textbf{Función de dibujo}
            La función de dibujo de círculos, llamada draw\_circle, se ejecuta por cada n círculo a dibujar de la siguiente manera: Primero, realiza la lectura de los datos de cada círculo, asignando los valores en cada lugar de un array. Luego empieza a realizar iteraciones entre la coordenada x e y, en un rango de -radio a + radio, y procede a realizar dos verificaciones, la primera si el punto actual está fuera de los límites de la imagen, y la segunda si el punto actual está dentro del círculo, con la ecuación de la circunferencia \begin{equation}\sqrt{x} + \sqrt{y} = \sqrt{r}\end{equation} Una vez realizado dichas validaciones, guarda los datos del píxel según canal de color y una función XOR, y los inserta en una posición. Una vez generado la lista de píxeles con su posición y respectivo color rgb, la función retorna dicha lista de píxeles a modificar en la imagen.
            \item \textbf{Función de escritura de archivo}
            La función de escritura de archivo, llamada writePPM, genera la imagen de salida final, iniciando con el header del archivo, luego genera una lista llamada rgb donde almacenará el color de cada píxel según posición. una vez realizado esto se guarda la imagen en un ''array.array'' y escribe el archivo PPM, retornando como resultado el archivo de salida.
        \end{itemize}

        \vspace{10mm}
        \item \textbf{Entorno de pruebas:}
            \begin{itemize}
                \item Procesador: AMD Ryzen 5 4600G with Radeon Graphics (12) @ 3.700GHz
                \item Memoria RAM: 15281 MiB
                \item Número de procesadores: 12
                \item Sistema Operativo: Windows 10 Home (64 bits)
                \item IDE de desarrollo y pruebas: Visual Studio Code
            \end{itemize}
        \item \textbf{Datos de entrada utilizados para las pruebas:}
            \begin{itemize}
                \item \textbf{Datos de entrada:}
                \begin{itemize}
                    \item Número de círculos: 20
                    \item Valores x, y, R, r, g, b por círculo:
                    \begin{itemize}
                        \item Círculo 1: -48 28 59 19 63 205
                        \item Círculo 2: 901 432 322 205 51 217
                        \item Círculo 3: 633 165 463 159 251 194
                        \item Círculo 4: -176 413 452 217 217 145
                        \item Círculo 5: 287 291 110 203 3 177
                        \item Círculo 6: 770 398 6 245 40 67
                        \item Círculo 7: 327 344 161 179 12 156
                        \item Círculo 8: 346 -73 19 8 90 155
                        \item Círculo 9: -10 -60 54 144 179 214
                        \item Círculo 10: -191 627 205 18 192 32
                        \item Círculo 11: -14 80 392 55 238 87
                        \item Círculo 12: 765 815 368 103 211 187
                        \item Círculo 13: 206 749 199 83 202 119
                        \item Círculo 14: 484 463 183 101 223 68
                        \item Círculo 15: 209 518 350 253 140 3
                        \item Círculo 16: 20 1004 217 227 192 181
                        \item Círculo 17: 648 -189 136 157 28 140
                        \item Círculo 18: 431 396 348 17 142 153
                        \item Círculo 19: 202 160 387 196 122 171
                        \item Círculo 20: 682 283 365 54 77 174
                    \end{itemize}
                \end{itemize}
            \end{itemize}

        \vspace{10mm}
        \item \textbf{Resultado de pruebas:}
            \begin{itemize}
                \item \textbf{Datos de entrada:}
                \begin{itemize}
                    \renewcommand{\theenumi}{\alph{enumi}}
                    \item Ejecución de pruebas:
                        \begin{figure}[H]
                            \includegraphics[width=1\linewidth, height=6cm]{cythonParalelo}
                            \caption{Ejecucion 7 a 10 en orden de izquierda a derecha}
                        \end{figure}
                    \item Benchmark:
                        \begin{figure}[H]
                            \begin{subfigure}{0.49\textwidth}
                                \includegraphics[width=1\linewidth, height=6cm]{TablaBench} 
                            \end{subfigure}
                            \begin{subfigure}{0.49\textwidth}
                                \includegraphics[width=1\linewidth, height=6cm]{GrafBench}
                            \end{subfigure}
                            \caption{Benchmark de las ejecuciones realizadas}
                        \end{figure}
                    \item Intervalos de confianza:
                        \begin{figure}[H]
                            \begin{subfigure}{0.49\textwidth}
                                \includegraphics[width=1\linewidth, height=6cm]{TablaCInt} 
                            \end{subfigure}
                            \begin{subfigure}{0.49\textwidth}
                                \includegraphics[width=1\linewidth, height=6cm]{BoxCInt}
                            \end{subfigure}
                            \caption{Tabla de intervalos de confianza y boxplot (de izquierda a derecha)}
                    \end{figure}
                \end{itemize}
            \end{itemize}
        \vspace{10mm}
        \item \textbf{Análisis de resultados:}
        Como hemos podido visualizar en el benchmark, el algoritmo de renderizado utilizando Cython en versión secuencial y paralela son los más rápidos en ejecución, obteniendo que en algunas ejecuciones la versión paralela es más rápida. Vemos que interesantemente, nuestras versiones paralelas con multiprocessing y threading son mucho más lentas que la versión secuencial en Python nativo. Podríamos concluir que el uso de Cython y en versión paralela mejoró considerablemente el rendimiento de nuestro algoritmo.
        \item \textbf{Anexo:}
        \begin{itemize}
            \item Ray Tracer: https://github.com/aysusayin/Ray-Tracer
        \end{itemize}
    \end{enumerate}
\end{flushleft}






\end{document}