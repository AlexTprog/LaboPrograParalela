\documentclass[12pt, letterpaper]{article}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{float}
\usepackage[spanish,es-tabla]{babel}
\graphicspath{{img/}}


\begin{document}

\begin{center}
    ''Año del Fortalecimiento de la Soberania Nacional''
    \vspace{5mm}
    \begin{figure}[h]
        \centering
        \includegraphics[width=4cm,height=4cm]{UNMSM}
    \end{figure}

    \textbf{Universidad Nacional Mayor de San marcos} \\
    (Universidad del Perú,DECANA DE AMERICA)\\
    \vspace{5mm}
    FACULTAD DE INGENIERIA DE SISTEMAS E INFORMATICA
    Escuela Profesional de Ingenieria de Software
    \begin{figure}[h]
        \centering   
        \includegraphics[width=2cm,height=2cm]{FISI}   
    \end{figure}

\textbf{\underline{Primera EC: Laboratorio Open MP}}

    \begin{flushleft}
    \textbf{Curso:}Programacion Paralela y Concurrente\\
    \vspace{2mm}
    \textbf{Profesor:} Edson Ticona Zegarra\\
    \vspace{2mm}
    \textbf{Integrantes:} 
    \begin{itemize}
        \item Pichilingue Pimentel, Nathaly Nicole\hspace{1cm} 19200247
        \item Torre Arteaga, Alexander\hspace{3.2cm}19200246
        \item Ricse Perez, Anthony Elias\hspace{3cm}19200276
    \end{itemize}
    \end{flushleft}

    Ciudad Universitaria 2022
 
\end{center}

\vspace{10mm}
\begin{flushleft}
    \begin{enumerate}
        \item \textbf{Explicación del algoritmo implementado}
        \begin{itemize}
            \item \textbf{Cuestiones generales}
            Las distintas versiones del algoritmo realizado fueron implementadas en Python, haciendo uso del Python nativo, y liberías como Cython y OpenMP.
            Para realizar la evaluación de la entrada, se creó una función que genera una lista de n círculos con sus respectivos datos como posición xy, radio y color rgb. Luego, en base a esos datos, se traza el círculo, se detecta los píxeles afectados y se realiza la modificación en el archivo PPM, lo que permite dibujar los círculos deseados.
            Consideraciones a tomar en nuestro código:
        \begin{itemize}
            \item Nuestro algoritmo solo toma como valores de entrada válidos, números enteros , negativos o positivos.
        \end{itemize}
            \item \textbf{Función principal}
            La función principal implementada en el proyecto llama a la función de entrada, donde ingresaremos los datos necesarios para dibujar el(los) circulo(s). Una vez se retorne la lista de cícrculos como respuesta, se llama a la función de creación de canvas en archivo PPM y luego a la función de dibujo, que nos retornará una matriz de píxeles. Con dicha matriz, se procede a llamar a la función de escritura de archivo, que modificará el canvas PPM creado incialmente según la posición y el canal de colores rgb de los píxeles obtenidos, finalizando así nla ejecución del programa.
            \item \textbf{Función de entrada}
            La función de entrada llamada "entrada" inicia solicitando al usuario que ingrese el número de círculos a dibujar, una vez obtenido el número de cícrlos, se realiza una loop para solicitar los siguiente datos por cada círculo: coordenada (x,y) que representa el eje del círculo, radio del círculo, y valores para cada canal de color rgb del círculo, en el orden rojo, verde y azul. Luego, guarda dichos datos en una lista llamada círculos y retorna dicha lista.
            \item \textbf{Función de creación de canvas}
            La función de creación del canvas, llamada "create_image", genera una imagen del tamaño 1024 x 960 preestablecido multiplicando con el valor de los canales de color negro, representado en rgb como 000 (respectivamente para cada canal de color), y finalmente guarda el resultado en una lista, que es el retorno de la función.
            \item \textbf{Función de dibujo}
            La función de dibujo de círculos, llamada "draw_circle", se ejecuta por cada n círculo a dibujar de la siguiente manera: Primero, realiza la lectura de los datos de cada círculo, asignando los valores en cada lugar de un array. Luego empieza a realizar iteraciones entre la coordenada x e y, en un rango de -radio a + radio, y procede a realizar dos verificaciones, la primera si el punto actual está fuera de los límites de la imagen, y la segunda si el punto actual está dentro del círculo, con la ecuación de la circunferencia \sqrt{x} + \sqrt{y} = \sqrt{r}. Una vez realidad dichas validaciones, guarda los datos del píxel según canal de color y una función XOR, y los inserta en una posición. Una vez generado la lista de píxeles con su posición y respectivo color rgb, la función retorna dicha lista de píxeles a modificar en la imagen.
            \item \textbf{Función de escritura de archivo}
            La función de escritura de archivo, llamada "writePPM", genera la imagen de salida final, iniciando con el header del archivo, luego genera una lista llamada rgb donde almacenará el color de cada píxel según posición. una vez realizado esto se guarda la imagen en un array.array y escribe el archivo PPM, retornando como resultado el archivo de salida.
        \end{itemize}

        \vspace{10mm}
        \item \textbf{Entorno de pruebas:}
            \begin{itemize}
                \item Procesador: AMD Ryzen 5 3500U with Radeon Vega Mobile Gfx  2.10 GHz
                \item Memoria RAM: 16 GB
                \item Número de procesadores: 8
                \item Sistema Operativo: 
                \item IDE de desarrollo y pruebas: Visual Studio Code
            \end{itemize}
        \item \textbf{Datos de entrada utilizados para las pruebas:}
        Poner texto aquí
        \item \textbf{Resultado de pruebas:}
        Poner texto aquí
        \item \textbf{Análisis de resultados:}
        Poner texto aquí
        \item \textbf{Anexo:}
        \begin{itemize}
            Ray Tracer: https://github.com/aysusayin/Ray-Tracer
        \end{itemize}
    \end{enumerate}
\end{flushleft}






\end{document}